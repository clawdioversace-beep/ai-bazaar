// src/db/schema.ts
// Source: orm.drizzle.team/docs/tutorials/drizzle-with-turso
//
// NOTE: FTS5 virtual table (listings_fts) and its sync triggers are NOT defined here.
// Drizzle ORM v0.45.1 does not support CREATE VIRTUAL TABLE in its schema DSL.
// The FTS5 table and triggers are created via a custom migration in src/db/migrations/.
// See: drizzle.config.ts for the WARNING against using `drizzle-kit push` in this project.
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';

/**
 * Main catalog listings table.
 *
 * Column conventions:
 * - JSON arrays stored as TEXT (tags, chainSupport): parse at read time
 * - Booleans stored as INTEGER with { mode: 'boolean' }
 * - Timestamps stored as INTEGER with { mode: 'timestamp' } (Unix ms)
 * - camelCase TypeScript fields map to snake_case SQL columns
 *
 * The FTS5 virtual table (listings_fts) syncs from this table via triggers.
 * All writes should go through CatalogService to ensure FTS5 stays in sync.
 */
export const listings = sqliteTable('listings', {
  /** UUID primary key — generated by crypto.randomUUID() in CatalogService */
  id: text('id').primaryKey(),

  /** URL-safe slug for listing pages, e.g. "anthropic-claude-mcp". Must be unique. */
  slug: text('slug').notNull().unique(),

  /** Display name of the tool or product */
  name: text('name').notNull(),

  /** Short description for cards and search results (max 160 chars) */
  tagline: text('tagline').notNull(),

  /** Full description supporting markdown (max 2000 chars) */
  description: text('description').notNull(),

  /** Canonical category — one of 6 values defined in src/lib/categories.ts */
  category: text('category').notNull(),

  /**
   * JSON array of normalized canonical tags, e.g. '["mcp-server","web3-tool"]'.
   * Always stored as JSON string. Use JSON.parse() to read, JSON.stringify() to write.
   * FTS5 index receives this raw JSON string — brackets and quotes are tokenized.
   * Tag-specific filtering uses exact JSON_EACH() or LIKE queries on this column,
   * not the FTS5 index. See SearchService for implementation details.
   */
  tags: text('tags').notNull(),

  /** Canonical source URL (dedup key). Normalized by CatalogEntry schema before write. */
  sourceUrl: text('source_url').notNull().unique(),

  /** Optional link to documentation */
  docsUrl: text('docs_url'),

  /** SPDX license identifier, e.g. "MIT", "Apache-2.0", "Proprietary" */
  licenseType: text('license_type'),

  /** Primary runtime environment: 'node' | 'python' | 'rust' | 'go' | 'other' */
  runtime: text('runtime'),

  /**
   * JSON array of supported blockchain networks, e.g. '["ethereum","solana"]'.
   * Null if the tool is not chain-specific.
   */
  chainSupport: text('chain_support'),

  /** True if this tool implements the Model Context Protocol (MCP) */
  mcpCompatible: integer('mcp_compatible', { mode: 'boolean' }).default(false),

  /** True if this tool implements the Agent Communication Protocol (ACP) */
  acpCompatible: integer('acp_compatible', { mode: 'boolean' }).default(false),

  /** GitHub stars or equivalent social proof metric */
  stars: integer('stars').default(0),

  /** npm/PyPI/package registry download count */
  downloads: integer('downloads').default(0),

  /** Community upvote count — incremented atomically via Server Action */
  upvotes: integer('upvotes').default(0),

  /** Timestamp of last automated health/availability check */
  lastVerifiedAt: integer('last_verified_at', { mode: 'timestamp' }),

  /**
   * True if the sourceUrl returns 404 or 410.
   * Only set after 3 consecutive dead checks — see health check worker.
   * Dead listings are excluded from search results.
   */
  deadLink: integer('dead_link', { mode: 'boolean' }).default(false),

  /** Identifier of submitter (wallet address, Twitter handle, or email). Null = scraped. */
  submittedBy: text('submitted_by'),

  /** True if a human editor has reviewed and approved this listing */
  verified: integer('verified', { mode: 'boolean' }).default(false),

  /** Row creation timestamp (set once at insert, never updated) */
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),

  /** Row last-modified timestamp (updated on every write) */
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

/** Full listing record returned by SELECT queries */
export type Listing = typeof listings.$inferSelect;

/** Listing shape for INSERT operations (timestamps and defaults may be omitted) */
export type NewListing = typeof listings.$inferInsert;
