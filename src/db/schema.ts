// src/db/schema.ts
// Source: orm.drizzle.team/docs/tutorials/drizzle-with-turso
//
// NOTE: FTS5 virtual table (listings_fts) and its sync triggers are NOT defined here.
// Drizzle ORM v0.45.1 does not support CREATE VIRTUAL TABLE in its schema DSL.
// The FTS5 table and triggers are created via a custom migration in src/db/migrations/.
// See: drizzle.config.ts for the WARNING against using `drizzle-kit push` in this project.
import { sqliteTable, text, integer, primaryKey } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';

/**
 * Main catalog listings table.
 *
 * Column conventions:
 * - JSON arrays stored as TEXT (tags, chainSupport): parse at read time
 * - Booleans stored as INTEGER with { mode: 'boolean' }
 * - Timestamps stored as INTEGER with { mode: 'timestamp' } (Unix ms)
 * - camelCase TypeScript fields map to snake_case SQL columns
 *
 * The FTS5 virtual table (listings_fts) syncs from this table via triggers.
 * All writes should go through CatalogService to ensure FTS5 stays in sync.
 */
export const listings = sqliteTable('listings', {
  /** UUID primary key — generated by crypto.randomUUID() in CatalogService */
  id: text('id').primaryKey(),

  /** URL-safe slug for listing pages, e.g. "anthropic-claude-mcp". Must be unique. */
  slug: text('slug').notNull().unique(),

  /** Display name of the tool or product */
  name: text('name').notNull(),

  /** Short description for cards and search results (max 160 chars) */
  tagline: text('tagline').notNull(),

  /** Full description supporting markdown (max 2000 chars) */
  description: text('description').notNull(),

  /** Canonical category — one of 6 values defined in src/lib/categories.ts */
  category: text('category').notNull(),

  /**
   * JSON array of normalized canonical tags, e.g. '["mcp-server","web3-tool"]'.
   * Always stored as JSON string. Use JSON.parse() to read, JSON.stringify() to write.
   * FTS5 index receives this raw JSON string — brackets and quotes are tokenized.
   * Tag-specific filtering uses exact JSON_EACH() or LIKE queries on this column,
   * not the FTS5 index. See SearchService for implementation details.
   */
  tags: text('tags').notNull(),

  /** Canonical source URL (dedup key). Normalized by CatalogEntry schema before write. */
  sourceUrl: text('source_url').notNull().unique(),

  /** Optional link to documentation */
  docsUrl: text('docs_url'),

  /** SPDX license identifier, e.g. "MIT", "Apache-2.0", "Proprietary" */
  licenseType: text('license_type'),

  /** Primary runtime environment: 'node' | 'python' | 'rust' | 'go' | 'other' */
  runtime: text('runtime'),

  /**
   * JSON array of supported blockchain networks, e.g. '["ethereum","solana"]'.
   * Null if the tool is not chain-specific.
   */
  chainSupport: text('chain_support'),

  /** True if this tool implements the Model Context Protocol (MCP) */
  mcpCompatible: integer('mcp_compatible', { mode: 'boolean' }).default(false),

  /** True if this tool implements the Agent Communication Protocol (ACP) */
  acpCompatible: integer('acp_compatible', { mode: 'boolean' }).default(false),

  /** GitHub stars or equivalent social proof metric */
  stars: integer('stars').default(0),

  /** npm/PyPI/package registry download count */
  downloads: integer('downloads').default(0),

  /** Community upvote count — incremented atomically via Server Action */
  upvotes: integer('upvotes').default(0),

  /** Timestamp of last automated health/availability check */
  lastVerifiedAt: integer('last_verified_at', { mode: 'timestamp' }),

  /**
   * True if the sourceUrl returns 404 or 410.
   * Only set after 3 consecutive dead checks — see health check worker.
   * Dead listings are excluded from search results.
   */
  deadLink: integer('dead_link', { mode: 'boolean' }).default(false),

  /** Identifier of submitter (wallet address, Twitter handle, or email). Null = scraped. */
  submittedBy: text('submitted_by'),

  /** True if a human editor has reviewed and approved this listing */
  verified: integer('verified', { mode: 'boolean' }).default(false),

  /** Row creation timestamp (set once at insert, never updated) */
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),

  /** Row last-modified timestamp (updated on every write) */
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),

  /**
   * Hype score (0-100) computed from stars, downloads, recency, and upvotes.
   * 0 = not yet scored or no signals. Updated by compute-hype-scores script.
   */
  hypeScore: integer('hype_score').default(0),

  /** Timestamp of last hype score computation (Unix ms) */
  hypeUpdatedAt: integer('hype_updated_at', { mode: 'timestamp' }),
});

/** Full listing record returned by SELECT queries */
export type Listing = typeof listings.$inferSelect;

/** Listing shape for INSERT operations (timestamps and defaults may be omitted) */
export type NewListing = typeof listings.$inferInsert;

/**
 * Starter packs — curated collections of tools for specific use cases.
 *
 * Each pack has a name, tagline, description, and links to multiple tools
 * through the packTools junction table. Packs enable discovery paths like
 * "DeFi Dev Starter" or "AI Agent Toolbox" that bundle 5-10 related tools.
 */
export const starterPacks = sqliteTable('starter_packs', {
  /** UUID primary key — generated by crypto.randomUUID() */
  id: text('id').primaryKey(),

  /** URL-safe slug for pack pages, e.g. "defi-dev-starter". Must be unique. */
  slug: text('slug').notNull().unique(),

  /** Display name of the pack */
  name: text('name').notNull(),

  /** Short tagline for pack cards (max 80 chars) */
  tagline: text('tagline').notNull(),

  /** Full description supporting markdown (max 500 chars) */
  description: text('description').notNull(),

  /** Optional cover image URL */
  coverImage: text('cover_image'),

  /** Row creation timestamp (set once at insert, never updated) */
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),

  /** Row last-modified timestamp (updated on every write) */
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

/**
 * Junction table for M:N relationship between starter packs and tools.
 *
 * Each row links one pack to one tool with ordering and narrative copy.
 * Composite primary key (pack_id, tool_id) prevents duplicate relationships.
 * Cascade deletes ensure cleanup when either pack or tool is removed.
 */
export const packTools = sqliteTable('pack_tools', {
  /** Foreign key to starter_packs.id */
  packId: text('pack_id').notNull().references(() => starterPacks.id, { onDelete: 'cascade' }),

  /** Foreign key to listings.id */
  toolId: text('tool_id').notNull().references(() => listings.id, { onDelete: 'cascade' }),

  /** Display order within the pack (1-based) */
  order: integer('order').notNull(),

  /** Narrative text explaining why this tool is in the pack (max 200 chars) */
  narrative: text('narrative').notNull(),
}, (t) => ({
  pk: primaryKey({ columns: [t.packId, t.toolId] }),
}));

// Drizzle relational query API setup
export const starterPacksRelations = relations(starterPacks, ({ many }) => ({
  tools: many(packTools),
}));

export const packToolsRelations = relations(packTools, ({ one }) => ({
  pack: one(starterPacks, {
    fields: [packTools.packId],
    references: [starterPacks.id],
  }),
  tool: one(listings, {
    fields: [packTools.toolId],
    references: [listings.id],
  }),
}));

export const listingsRelations = relations(listings, ({ many }) => ({
  packs: many(packTools),
}));

/** Full starter pack record returned by SELECT queries */
export type StarterPack = typeof starterPacks.$inferSelect;

/** Starter pack shape for INSERT operations (timestamps may be omitted) */
export type NewStarterPack = typeof starterPacks.$inferInsert;

/** Full pack-tool junction record returned by SELECT queries */
export type PackTool = typeof packTools.$inferSelect;

/** Pack-tool junction shape for INSERT operations */
export type NewPackTool = typeof packTools.$inferInsert;

/**
 * Curated reads — external links to the best AI threads, articles, tutorials, and guides.
 *
 * Each read points to an external URL with a title, summary, source info, and tags.
 * No detail page — cards link directly to the external source.
 */
export const reads = sqliteTable('reads', {
  /** UUID primary key */
  id: text('id').primaryKey(),

  /** URL-safe slug for URL construction and dedup */
  slug: text('slug').notNull().unique(),

  /** Display title of the read */
  title: text('title').notNull(),

  /** 1-3 sentence summary of the content */
  summary: text('summary').notNull(),

  /** External link to the content */
  sourceUrl: text('source_url').notNull().unique(),

  /** Source platform name: "Twitter", "Blog", "YouTube", etc. */
  sourceName: text('source_name').notNull(),

  /** Original author if known */
  author: text('author'),

  /** JSON array of tags, same format as listings */
  tags: text('tags').notNull(),

  /** Content type: "thread", "article", "tutorial", "video", "guide" */
  category: text('category').notNull(),

  /** When the original content was published */
  publishedAt: integer('published_at', { mode: 'timestamp' }),

  /** Row creation timestamp */
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),

  /** Whether this read is featured on the homepage */
  featured: integer('featured', { mode: 'boolean' }).notNull().default(false),
});

/** Full read record returned by SELECT queries */
export type Read = typeof reads.$inferSelect;

/** Read shape for INSERT operations */
export type NewRead = typeof reads.$inferInsert;
