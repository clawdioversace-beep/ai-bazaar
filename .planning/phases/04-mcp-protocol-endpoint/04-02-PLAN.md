---
phase: 04-mcp-protocol-endpoint
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/lib/__tests__/mcp-tools.test.ts
autonomous: true

must_haves:
  truths:
    - "search_catalog returns matching listings with pagination metadata when given a valid query"
    - "search_catalog returns nextCursor when more results exist, and omits it on last page"
    - "get_listing returns full listing detail when given a valid slug"
    - "get_listing returns isError true when given a non-existent slug"
    - "submit_listing creates a new entry from a sourceUrl and returns its slug and ID"
    - "submit_listing upserts (not duplicates) when called with an existing sourceUrl"
    - "All tool errors return isError true with safe messages, not stack traces"
  artifacts:
    - path: "src/lib/__tests__/mcp-tools.test.ts"
      provides: "Integration tests for all 3 MCP tools"
      min_lines: 80
  key_links:
    - from: "src/lib/__tests__/mcp-tools.test.ts"
      to: "src/services/search.ts"
      via: "searchCatalog called through MCP tool"
      pattern: "searchCatalog"
    - from: "src/lib/__tests__/mcp-tools.test.ts"
      to: "src/services/catalog.ts"
      via: "CatalogService functions called through MCP tools"
      pattern: "getListingBySlug|upsertBySourceUrl"
---

<objective>
Test all three MCP tools (search_catalog, get_listing, submit_listing) against a real SQLite database to verify correct service wiring, pagination behavior, error handling, and idempotent submission.

Purpose: MCP tools are the agent-facing API — if they return wrong data or break on edge cases, every AI agent using the catalog gets bad results. These tests verify the business logic layer works correctly end-to-end.

Output: A passing test suite confirming all MCP tool behaviors match Phase 4 success criteria.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-protocol-endpoint/04-01-SUMMARY.md
@src/services/catalog.ts
@src/services/search.ts
@src/lib/__tests__/catalog-service.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP tools integration tests</name>
  <files>src/lib/__tests__/mcp-tools.test.ts</files>
  <action>
Create `src/lib/__tests__/mcp-tools.test.ts` that tests the MCP tool logic by calling the underlying service functions directly (same as the route handler calls them). This avoids the complexity of standing up a full MCP transport for testing — the transport layer is mcp-handler's responsibility, tested by Vercel. Our tests verify our business logic wiring.

**IMPORTANT PATTERN (from 01-03 decision):** Use dynamic imports in `beforeAll`, not static imports. The db client reads `TURSO_DATABASE_URL` at module init, so the env var must be set before any service modules load.

```typescript
import { describe, test, expect, beforeAll, afterAll } from 'bun:test';
import { execSync } from 'child_process';
```

**Setup (beforeAll):**
1. Set `process.env.TURSO_DATABASE_URL = 'file:./test-mcp.db'`
2. Delete `test-mcp.db` if it exists (clean slate)
3. Run migrations: `execSync('TURSO_DATABASE_URL=file:./test-mcp.db bun src/db/migrate.ts')`
4. Dynamically import services:
   ```typescript
   const catalogMod = await import('@/services/catalog');
   const searchMod = await import('@/services/search');
   ```
5. Seed test data: Create 3 listings via `catalogMod.createListing()`:
   - `{ slug: 'test-mcp-tool', name: 'Test MCP Tool', tagline: 'A test tool', description: 'Full description', category: 'mcp-server', tags: ['mcp-server'], sourceUrl: 'https://github.com/test/mcp-tool', mcpCompatible: true }`
   - `{ slug: 'test-defi-agent', name: 'Test DeFi Agent', tagline: 'A DeFi agent', description: 'Full description for agent', category: 'ai-agent', tags: ['ai-agent', 'defi'], sourceUrl: 'https://github.com/test/defi-agent', mcpCompatible: false }`
   - `{ slug: 'test-web3-sdk', name: 'Test Web3 SDK', tagline: 'A Web3 SDK', description: 'Full description for SDK', category: 'web3-tool', tags: ['web3'], sourceUrl: 'https://github.com/test/web3-sdk', mcpCompatible: false }`
6. Rebuild FTS index: `await searchMod.rebuildFtsIndex()`

**Teardown (afterAll):**
1. Delete `test-mcp.db`

**Test cases:**

**describe('search_catalog tool logic'):**

1. `test('returns results for valid keyword query')`:
   - Call `searchMod.searchCatalog({ query: 'MCP', limit: 20, offset: 0 })`
   - Expect results.length >= 1
   - Expect first result to have `slug: 'test-mcp-tool'`

2. `test('filters by mcpCompatible')`:
   - Call `searchMod.searchCatalog({ query: 'test', mcpCompatible: true, limit: 20, offset: 0 })`
   - Expect all results to have mcpCompatible truthy (1 or true depending on SQLite return)

3. `test('cursor pagination: returns nextCursor when more results')`:
   - Call with `limit: 1, offset: 0`
   - Expect results.length === 1
   - Compute: `const nextCursor = results.length === 1 ? btoa(JSON.stringify({ offset: 1 })) : undefined`
   - Expect nextCursor to be defined (truthy)
   - Decode: `JSON.parse(atob(nextCursor))` should equal `{ offset: 1 }`

4. `test('cursor pagination: no nextCursor on last page')`:
   - Call with `limit: 100, offset: 0`
   - Since we have 3 entries and limit is 100, results.length < 100
   - `const nextCursor = results.length === 100 ? btoa(...) : undefined`
   - Expect nextCursor to be undefined

**describe('get_listing tool logic'):**

5. `test('returns listing by slug')`:
   - Call `catalogMod.getListingBySlug('test-mcp-tool')`
   - Expect result to be defined
   - Expect `result.name` to be `'Test MCP Tool'`
   - Expect `result.sourceUrl` to contain `'github.com/test/mcp-tool'`

6. `test('returns listing by UUID')`:
   - Get listing first: `const listing = await catalogMod.getListingBySlug('test-mcp-tool')`
   - Call `catalogMod.getListingById(listing.id)`
   - Expect result to be defined
   - Expect `result.slug` to be `'test-mcp-tool'`

7. `test('returns undefined for non-existent slug')`:
   - Call `catalogMod.getListingBySlug('does-not-exist')`
   - Expect result to be undefined

**describe('submit_listing tool logic'):**

8. `test('creates new listing from sourceUrl')`:
   - Call `catalogMod.upsertBySourceUrl({ slug: 'new-submission', name: 'New Submission', tagline: 'Submitted via MCP', description: 'Test submission', category: 'other', tags: [], sourceUrl: 'https://github.com/test/new-submission' })`
   - Expect result to have `slug: 'new-submission'`
   - Expect result.id to be a UUID string

9. `test('upserts existing sourceUrl without duplicating')`:
   - Call upsertBySourceUrl again with SAME sourceUrl but different name:
   `catalogMod.upsertBySourceUrl({ slug: 'new-submission-v2', name: 'New Submission V2', tagline: 'Updated', description: 'Updated description', category: 'other', tags: [], sourceUrl: 'https://github.com/test/new-submission' })`
   - Fetch by original slug OR new slug — the point is no duplicate exists
   - Use getAllListings to count: should NOT have 2 entries with same sourceUrl

**Error handling:**

10. `test('search with empty string throws or returns empty')`:
    - Call `searchMod.searchCatalog({ query: '', limit: 20, offset: 0 })` wrapped in try/catch
    - Either throws (FTS5 rejects empty MATCH) or returns empty array — both acceptable
    - The MCP tool layer catches this and returns isError: true

File should use the established test pattern from `catalog-service.test.ts` — dynamic imports, file-based SQLite, migrations via execSync.
  </action>
  <verify>
```bash
cd /Users/clawdioversace/ai-bazaar && TURSO_DATABASE_URL=file:./test-mcp.db bun test src/lib/__tests__/mcp-tools.test.ts
```
All tests pass. No test-mcp.db left behind after suite completion.
  </verify>
  <done>
All 10 test cases pass: search with keywords, mcpCompatible filter, cursor pagination (has next, no next on last page), get by slug, get by UUID, not-found returns undefined, submit creates new, upsert deduplicates, error handling for empty query.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify MCP endpoint with dev server smoke test</name>
  <files></files>
  <action>
Run a quick smoke test against the dev server to confirm the MCP endpoint is actually reachable:

1. Start the dev server (if not already running):
   ```bash
   cd /Users/clawdioversace/ai-bazaar && TURSO_DATABASE_URL=file:./dev.db bun run dev &
   ```
   Wait for "Ready" message.

2. Test that the MCP endpoint responds (not 404):
   ```bash
   curl -s -o /dev/null -w '%{http_code}' http://localhost:3000/api/mcp
   ```
   Acceptable responses: 200, 400, 405 (method depends on MCP handshake). NOT 404.

3. Test with a proper MCP initialize request (POST with JSON-RPC):
   ```bash
   curl -s -X POST http://localhost:3000/api/mcp \
     -H 'Content-Type: application/json' \
     -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}'
   ```
   Should return a JSON-RPC response with `serverInfo` containing `name: "ai-bazaar-mcp"`.

4. Kill the dev server when done.

If the endpoint returns 404, check:
- File is at `src/app/api/[transport]/route.ts` (not `src/app/api/mcp/route.ts`)
- `basePath` in handler options is `/api`
- Next.js dynamic route `[transport]` resolves `mcp` segment

This task is verification-only — no files created. If something is broken, fix it in the route file and re-test.
  </action>
  <verify>
The MCP endpoint at `/api/mcp` returns a valid MCP initialize response (not 404, not 500). The response JSON contains `"name":"ai-bazaar-mcp"`.
  </verify>
  <done>
MCP endpoint at /api/mcp responds to initialize request with server info. Dev server handles the Streamable HTTP transport correctly.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/lib/__tests__/mcp-tools.test.ts` — all tests pass
2. MCP endpoint responds at `/api/mcp` (not 404)
3. MCP initialize handshake returns server info with `name: "ai-bazaar-mcp"`
4. No test artifacts left behind (test-mcp.db cleaned up)
</verification>

<success_criteria>
- All MCP tool integration tests pass (search, get, submit, pagination, errors)
- MCP endpoint reachable at /api/mcp via dev server
- MCP initialize handshake succeeds
- Upsert deduplication verified by test
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-protocol-endpoint/04-02-SUMMARY.md`
</output>
