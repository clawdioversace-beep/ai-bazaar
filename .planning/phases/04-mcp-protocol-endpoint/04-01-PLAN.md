---
phase: 04-mcp-protocol-endpoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/app/api/[transport]/route.ts
autonomous: true

must_haves:
  truths:
    - "An MCP client can connect to /api/mcp via Streamable HTTP and list 3 tools + 1 resource"
    - "search_catalog tool returns JSON results with cursor-based pagination (nextCursor in meta)"
    - "get_listing tool returns full listing detail by slug, or isError for missing slugs"
    - "submit_listing tool creates/upserts a catalog entry from a sourceUrl"
    - "catalog-schema resource returns the CatalogEntrySchema shape as JSON"
  artifacts:
    - path: "src/app/api/[transport]/route.ts"
      provides: "MCP server handler with tools and resource"
      exports: ["GET", "POST"]
    - path: "package.json"
      provides: "mcp-handler and @modelcontextprotocol/sdk dependencies"
      contains: "mcp-handler"
  key_links:
    - from: "src/app/api/[transport]/route.ts"
      to: "src/services/search.ts"
      via: "searchCatalog import"
      pattern: "import.*searchCatalog.*from.*services/search"
    - from: "src/app/api/[transport]/route.ts"
      to: "src/services/catalog.ts"
      via: "getListingBySlug and upsertBySourceUrl imports"
      pattern: "import.*getListingBySlug.*from.*services/catalog"
    - from: "src/app/api/[transport]/route.ts"
      to: "src/lib/catalog-schema.ts"
      via: "CatalogEntrySchema import for resource"
      pattern: "import.*CatalogEntrySchema.*from.*lib/catalog-schema"
---

<objective>
Create the MCP server endpoint at `/api/[transport]/route.ts` with all three tools (`search_catalog`, `get_listing`, `submit_listing`) and the catalog schema resource, wired to existing CatalogService and SearchService.

Purpose: This is the core Phase 4 deliverable — making the AI Bazaar catalog queryable by AI agents via the Model Context Protocol. All three tools and the resource are defined in one route file because they share the same server instance and have no independent lifecycle.

Output: A working MCP server at `/api/mcp` that agents can connect to via Streamable HTTP transport.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-protocol-endpoint/04-RESEARCH.md
@src/services/catalog.ts
@src/services/search.ts
@src/lib/catalog-schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP dependencies</name>
  <files>package.json</files>
  <action>
Install `mcp-handler` and `@modelcontextprotocol/sdk@^1.25.2` using bun:

```bash
cd /Users/clawdioversace/ai-bazaar && bun install mcp-handler @modelcontextprotocol/sdk@^1.25.2
```

Note: `zod` is already installed (^3.25.0). Do NOT upgrade zod — v4 has breaking changes (decision from 01-01).

Verify both packages appear in package.json dependencies after install.
  </action>
  <verify>
`bun install` succeeds without errors. `package.json` contains `"mcp-handler"` and `"@modelcontextprotocol/sdk"` in dependencies. Run `bun run build` to confirm no type conflicts.
  </verify>
  <done>
mcp-handler and @modelcontextprotocol/sdk are in package.json dependencies and bun install resolves cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MCP route handler with tools and resource</name>
  <files>src/app/api/[transport]/route.ts</files>
  <action>
Create `src/app/api/[transport]/route.ts` with the following implementation:

**CRITICAL API NOTE:** The research file shows `server.registerTool()` and `server.registerResource()` but the ACTUAL mcp-handler API uses:
- `server.tool(name, description, zodSchema, handler)` for tools
- `server.resource(uri, description, handler)` for resources
Use the correct API from Context7 verification, NOT the research file signatures.

**Server setup:**
```typescript
import { createMcpHandler } from 'mcp-handler';
import { z } from 'zod';
import { searchCatalog } from '@/services/search';
import { getListingBySlug, getListingById, upsertBySourceUrl } from '@/services/catalog';
import { CatalogEntrySchema, createSlug } from '@/lib/catalog-schema';
```

Create the handler with `createMcpHandler((server) => { ... }, serverOptions, handlerOptions)`:

**serverOptions** (second arg):
```typescript
{
  serverInfo: {
    name: 'ai-bazaar-mcp',
    version: '0.1.0',
  },
  capabilities: {
    tools: {},
    resources: {},
  },
}
```

**handlerOptions** (third arg):
```typescript
{
  basePath: '/api',
  maxDuration: 60,
  verboseLogs: process.env.NODE_ENV === 'development',
}
```
No `redisUrl` — this is a stateless server, no Redis needed.

**Tool 1: search_catalog**
```typescript
server.tool(
  'search_catalog',
  'Search the AI Bazaar catalog for tools, agents, and protocols. Supports keyword search with optional category and MCP-compatibility filters. Returns paginated results.',
  {
    query: z.string().min(1).describe('Search query (FTS5 full-text search)'),
    category: z.string().optional().describe('Filter by category slug (e.g. "mcp-server", "ai-agent", "defi-tool")'),
    mcpCompatible: z.boolean().optional().describe('Filter to MCP-compatible tools only'),
    cursor: z.string().optional().describe('Pagination cursor from previous response (opaque string)'),
  },
  async ({ query, category, mcpCompatible, cursor }) => {
    try {
      const decoded = cursor ? JSON.parse(atob(cursor)) : { offset: 0 };
      const limit = 20;

      const results = await searchCatalog({
        query,
        category,
        mcpCompatible,
        limit,
        offset: decoded.offset,
      });

      const nextCursor = results.length === limit
        ? btoa(JSON.stringify({ offset: decoded.offset + limit }))
        : undefined;

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            results,
            pagination: {
              nextCursor,
              hasMore: results.length === limit,
              count: results.length,
            },
          }, null, 2),
        }],
      };
    } catch (error) {
      console.error('search_catalog error:', error);
      return {
        isError: true,
        content: [{
          type: 'text' as const,
          text: 'Failed to search catalog. Please check your query syntax.',
        }],
      };
    }
  }
);
```

**Tool 2: get_listing**
```typescript
server.tool(
  'get_listing',
  'Get full details for a specific catalog listing by its slug or UUID. Returns all metadata including description, tags, links, and metrics.',
  {
    identifier: z.string().min(1).describe('Listing slug (e.g. "anthropic-claude-mcp") or UUID'),
  },
  async ({ identifier }) => {
    try {
      // Try slug first (more common), fall back to UUID
      let listing = await getListingBySlug(identifier);
      if (!listing) {
        // Check if it looks like a UUID
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (uuidRegex.test(identifier)) {
          listing = await getListingById(identifier);
        }
      }

      if (!listing) {
        return {
          isError: true,
          content: [{
            type: 'text' as const,
            text: `Listing not found: ${identifier}`,
          }],
        };
      }

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify(listing, null, 2),
        }],
      };
    } catch (error) {
      console.error('get_listing error:', error);
      return {
        isError: true,
        content: [{
          type: 'text' as const,
          text: 'Failed to fetch listing details.',
        }],
      };
    }
  }
);
```

**Tool 3: submit_listing**
```typescript
server.tool(
  'submit_listing',
  'Submit a new tool or project to the AI Bazaar catalog. Provide a source URL (GitHub, npm, etc.) with optional name and category. Duplicate URLs are handled via upsert.',
  {
    sourceUrl: z.string().url().describe('Primary URL of the tool (GitHub repo, npm package, etc.)'),
    name: z.string().optional().describe('Tool name (auto-generated from URL if omitted)'),
    category: z.string().optional().describe('Category slug (defaults to "other" if omitted)'),
  },
  async ({ sourceUrl, name, category }) => {
    try {
      const slug = name ? createSlug(name) : createSlug(new URL(sourceUrl).pathname.split('/').filter(Boolean).slice(-1)[0] || 'pending');

      const entry = await upsertBySourceUrl({
        slug,
        name: name ?? slug.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
        tagline: 'Submitted via MCP — enrichment pending',
        description: 'This listing was submitted programmatically via the MCP protocol. Full details will be enriched by the scraping pipeline.',
        category: category ?? 'other',
        tags: [],
        sourceUrl,
      });

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            status: 'created',
            slug: entry.slug,
            id: entry.id,
            message: `Listing "${entry.name}" created/updated successfully.`,
          }, null, 2),
        }],
      };
    } catch (error) {
      console.error('submit_listing error:', error);
      return {
        isError: true,
        content: [{
          type: 'text' as const,
          text: 'Failed to submit listing. Please verify the URL is valid.',
        }],
      };
    }
  }
);
```

**Resource: catalog-schema**
```typescript
server.resource(
  'schema://ai-bazaar/catalog-entry',
  'Machine-readable Zod schema for AI Bazaar catalog entries. Use this to understand the data structure for submissions and search results.',
  async (uri) => ({
    contents: [{
      uri: uri.href,
      mimeType: 'application/json',
      text: JSON.stringify({
        description: 'AI Bazaar Catalog Entry Schema',
        fields: {
          slug: 'URL-safe identifier (lowercase alphanumeric + hyphens)',
          name: 'Display name (1-100 chars)',
          tagline: 'Short description (1-160 chars)',
          description: 'Full description with markdown (1-2000 chars)',
          category: 'One of: mcp-server, ai-agent, web3-tool, defi-tool, infrastructure, other',
          tags: 'Array of normalized tag strings',
          sourceUrl: 'Primary URL (GitHub, npm, etc.)',
          docsUrl: 'Optional documentation URL',
          licenseType: 'SPDX identifier (MIT, Apache-2.0, etc.)',
          runtime: 'One of: node, python, rust, go, other',
          chainSupport: 'Array of blockchain names (ethereum, solana, etc.)',
          mcpCompatible: 'Boolean — implements Model Context Protocol',
          acpCompatible: 'Boolean — implements Agent Communication Protocol',
          stars: 'GitHub stars or equivalent metric',
          downloads: 'Registry download count',
        },
        example: {
          slug: 'example-mcp-tool',
          name: 'Example MCP Tool',
          tagline: 'A reference implementation for MCP servers',
          description: 'Full description here...',
          category: 'mcp-server',
          tags: ['mcp-server', 'reference'],
          sourceUrl: 'https://github.com/org/repo',
          mcpCompatible: true,
        },
      }, null, 2),
    }],
  })
);
```

Export the handler:
```typescript
export { handler as GET, handler as POST, handler as DELETE };
```

Note: DELETE export is required by mcp-handler for session cleanup (even for stateless servers).

**Error handling pattern:** Every tool handler wraps its body in try/catch. Caught errors are logged server-side via `console.error()` and return `isError: true` with a safe message. Stack traces and internal details never leak to clients.

**Cursor pagination pattern:** Base64-encoded JSON `{ offset: number }`. Decoded with `JSON.parse(atob(cursor))`, encoded with `btoa(JSON.stringify({ offset }))`. `nextCursor` is only included when `results.length === limit` (meaning there might be more results).
  </action>
  <verify>
1. File exists at `src/app/api/[transport]/route.ts`
2. `bun run build` succeeds (type checks pass)
3. Start dev server: `bun run dev`
4. Test MCP connection: `curl -s http://localhost:3000/api/mcp | head -20` (should return MCP protocol response, not 404)
  </verify>
  <done>
MCP route handler exists with 3 tools (search_catalog, get_listing, submit_listing) and 1 resource (catalog-schema). Next.js build succeeds. Dev server responds at /api/mcp.
  </done>
</task>

</tasks>

<verification>
1. `bun run build` passes — no TypeScript errors, no import resolution failures
2. `bun run dev` starts and `/api/mcp` responds (not 404)
3. All three tools are registered with proper Zod input schemas
4. Catalog schema resource is registered at `schema://ai-bazaar/catalog-entry`
5. Error handling returns `isError: true` with safe messages (no stack traces)
6. Cursor pagination encodes/decodes correctly with base64 JSON
</verification>

<success_criteria>
- MCP handler is installed and configured at `/api/[transport]/route.ts`
- Three tools (search_catalog, get_listing, submit_listing) are registered
- Catalog schema resource is registered
- `bun run build` succeeds
- Dev server serves MCP endpoint at `/api/mcp`
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-protocol-endpoint/04-01-SUMMARY.md`
</output>
