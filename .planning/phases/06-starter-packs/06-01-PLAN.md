---
phase: 06-starter-packs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/db/migrations/0003_starter_packs.sql
  - src/db/migrate.ts
  - src/db/client.ts
  - src/services/packs.ts
  - src/db/seed-packs.ts
autonomous: true

must_haves:
  truths:
    - "starterPacks and packTools tables exist in the database after migration"
    - "packTools has composite primary key (pack_id, tool_id) preventing duplicate tool-pack relationships"
    - "Deleting a pack cascades to remove its pack_tools rows"
    - "Deleting a listing cascades to remove its pack_tools rows"
    - "getPackWithTools returns a pack with ordered tools and their full listing data"
    - "listPacks returns all packs ordered by creation date"
    - "At least 3 starter packs with 5-10 tools each are seeded into the database"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "starterPacks table, packTools junction table, relations for both"
      contains: "starterPacks"
    - path: "src/db/migrations/0003_starter_packs.sql"
      provides: "CREATE TABLE for starter_packs and pack_tools with indexes"
      contains: "CREATE TABLE"
    - path: "src/services/packs.ts"
      provides: "Pack query functions"
      exports: ["getPackWithTools", "listPacks"]
    - path: "src/db/seed-packs.ts"
      provides: "Seed script for 3-5 starter packs with narrative copy"
      min_lines: 80
  key_links:
    - from: "src/db/schema.ts"
      to: "src/db/schema.ts"
      via: "packTools.packId references starterPacks.id, packTools.toolId references listings.id"
      pattern: "references.*starterPacks|references.*listings"
    - from: "src/services/packs.ts"
      to: "src/db/schema.ts"
      via: "Drizzle relational queries using .with() for nested tool loading"
      pattern: "db\\.query\\.starterPacks"
    - from: "src/db/seed-packs.ts"
      to: "src/services/packs.ts"
      via: "Uses db client to insert packs and junction rows"
      pattern: "db\\.insert.*starterPacks|db\\.insert.*packTools"
    - from: "src/db/client.ts"
      to: "src/db/schema.ts"
      via: "Schema import includes new tables and relations for query builder"
      pattern: "import.*schema"
---

<objective>
Starter pack data model, migration, relations, service layer, and seed data.

Purpose: Creates the database foundation for curated starter packs — two new tables (starter_packs, pack_tools junction), Drizzle relations for nested queries, a service layer for fetching packs with their tools, and a seed script that populates 3-5 packs with narrative copy linking to existing catalog tools.

Output: Schema additions in schema.ts, SQL migration 0003, updated migrate.ts, pack service with getPackWithTools/listPacks, seed script with 3+ packs.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-starter-packs/06-RESEARCH.md
@src/db/schema.ts
@src/db/client.ts
@src/db/migrate.ts
@src/db/migrations/0002_add-upvotes-column.sql
@src/services/catalog.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add starter pack tables, relations, and migration to schema</name>
  <files>
    src/db/schema.ts
    src/db/migrations/0003_starter_packs.sql
    src/db/migrate.ts
  </files>
  <action>
    **In src/db/schema.ts — append after the existing `listings` table definition:**

    1. Add `import { relations } from 'drizzle-orm';` at the top (alongside existing imports from `drizzle-orm/sqlite-core`)

    2. Add `starterPacks` table definition:
       ```
       export const starterPacks = sqliteTable('starter_packs', {
         id:          text('id').primaryKey(),
         slug:        text('slug').notNull().unique(),
         name:        text('name').notNull(),
         tagline:     text('tagline').notNull(),
         description: text('description').notNull(),
         coverImage:  text('cover_image'),
         createdAt:   integer('created_at', { mode: 'timestamp' }).notNull(),
         updatedAt:   integer('updated_at', { mode: 'timestamp' }).notNull(),
       });
       ```

    3. Add `packTools` junction table with composite primary key:
       ```
       export const packTools = sqliteTable('pack_tools', {
         packId:    text('pack_id').notNull().references(() => starterPacks.id, { onDelete: 'cascade' }),
         toolId:    text('tool_id').notNull().references(() => listings.id, { onDelete: 'cascade' }),
         order:     integer('order').notNull(),
         narrative: text('narrative').notNull(),
       }, (t) => ({
         pk: primaryKey({ columns: [t.packId, t.toolId] }),
       }));
       ```
       Import `primaryKey` from `drizzle-orm/sqlite-core`.

    4. Add Drizzle relations for the relational query API:
       ```
       export const starterPacksRelations = relations(starterPacks, ({ many }) => ({
         tools: many(packTools),
       }));

       export const packToolsRelations = relations(packTools, ({ one }) => ({
         pack: one(starterPacks, {
           fields: [packTools.packId],
           references: [starterPacks.id],
         }),
         tool: one(listings, {
           fields: [packTools.toolId],
           references: [listings.id],
         }),
       }));

       export const listingsRelations = relations(listings, ({ many }) => ({
         packs: many(packTools),
       }));
       ```

    5. Add type exports:
       ```
       export type StarterPack = typeof starterPacks.$inferSelect;
       export type NewStarterPack = typeof starterPacks.$inferInsert;
       export type PackTool = typeof packTools.$inferSelect;
       export type NewPackTool = typeof packTools.$inferInsert;
       ```

    **In src/db/migrations/0003_starter_packs.sql (new file):**

    Write a manual SQL migration (same pattern as 0001 and 0002):
    ```sql
    -- Manual migration: Starter packs tables for Phase 6
    -- Creates starter_packs table and pack_tools junction table for M:N relationship

    CREATE TABLE IF NOT EXISTS starter_packs (
      id TEXT PRIMARY KEY NOT NULL,
      slug TEXT NOT NULL UNIQUE,
      name TEXT NOT NULL,
      tagline TEXT NOT NULL,
      description TEXT NOT NULL,
      cover_image TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    );

    CREATE TABLE IF NOT EXISTS pack_tools (
      pack_id TEXT NOT NULL REFERENCES starter_packs(id) ON DELETE CASCADE,
      tool_id TEXT NOT NULL REFERENCES listings(id) ON DELETE CASCADE,
      "order" INTEGER NOT NULL,
      narrative TEXT NOT NULL,
      PRIMARY KEY (pack_id, tool_id)
    );

    -- Indexes for join performance
    CREATE INDEX IF NOT EXISTS idx_pack_tools_pack_id ON pack_tools(pack_id);
    CREATE INDEX IF NOT EXISTS idx_pack_tools_tool_id ON pack_tools(tool_id);
    ```

    **IMPORTANT:** `order` is a reserved word in SQL — quote it as `"order"` in the migration. Drizzle handles this automatically in queries but the raw SQL migration needs explicit quoting.

    **In src/db/migrate.ts:**

    No changes needed — the custom migration runner already picks up all .sql files from src/db/migrations/ in alphabetical order. The starter_packs migration has no triggers or BEGIN...END blocks, so drizzle-kit's default runner handles it fine.

    However, verify the migrations folder path is correctly specified. The existing migrate.ts uses `migrationsFolder: './src/db/migrations'` which will pick up the new 0003 file automatically.
  </action>
  <verify>
    TypeScript compiles: `cd /Users/clawdioversace/ai-bazaar && bunx tsc --noEmit --pretty 2>&1 | head -30`
    Schema exports exist: `grep -n 'starterPacks\|packTools\|starterPacksRelations\|packToolsRelations\|listingsRelations' src/db/schema.ts`
    Migration file exists: `cat src/db/migrations/0003_starter_packs.sql`
    Run migration: `cd /Users/clawdioversace/ai-bazaar && TURSO_DATABASE_URL=file:./dev.db bun src/db/migrate.ts 2>&1`
  </verify>
  <done>
    starterPacks and packTools tables defined in schema.ts with relations. SQL migration 0003 creates both tables with indexes. Migration runs successfully against dev.db. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pack service layer and seed script with 3+ packs</name>
  <files>
    src/services/packs.ts
    src/db/seed-packs.ts
  </files>
  <action>
    **In src/services/packs.ts (new file):**

    Create a service module following the same pattern as catalog.ts and search.ts (service-only DB access):

    ```typescript
    import { eq, asc } from 'drizzle-orm';
    import { db } from '../db/client';
    import { starterPacks, packTools } from '../db/schema';
    ```

    1. `getPackWithTools(slug: string)` — fetch a single pack by slug with all its tools:
       - Use `db.query.starterPacks.findFirst()` with:
         - `where: eq(starterPacks.slug, slug)`
         - `with: { tools: { orderBy: [asc(packTools.order)], with: { tool: true } } }`
       - Returns the pack with nested `tools` array where each entry has `order`, `narrative`, and the full `tool` listing record
       - Returns `undefined` if slug not found

    2. `listPacks()` — fetch all packs for the browse page:
       - Use `db.query.starterPacks.findMany()` with:
         - `orderBy: [asc(starterPacks.createdAt)]`
       - Returns array of packs (without tool details — browse page only needs name/tagline/slug)

    3. `listPacksWithToolCount()` — fetch all packs with tool counts for the browse page:
       - Use raw SQL or a separate query to count tools per pack
       - Alternative: Use `db.query.starterPacks.findMany({ with: { tools: true } })` and compute `.tools.length` in application code
       - This is optional if the browse page card only needs name/tagline (the simpler `listPacks()` suffices)
       - SKIP this function — the browse page only shows 3-5 cards and doesn't need tool counts. Simpler is better.

    **In src/db/seed-packs.ts (new file):**

    Create a seed script that populates 3-5 starter packs. The script should:

    1. Import `db` from `'./client'`, `starterPacks`, `packTools`, `listings` from `'./schema'`
    2. Import `eq` from `'drizzle-orm'`

    3. Define pack seed data with 3 packs minimum. Each pack needs:
       - `name`, `slug`, `tagline`, `description` (narrative intro paragraph)
       - `tools`: array of `{ toolSlug, order, narrative }` with 5-10 entries per pack

       **Pack 1: "DeFi Dev Starter"**
       - Slug: `defi-dev-starter`
       - Tagline: "Everything you need to build DeFi apps"
       - 5-8 tools related to DeFi/blockchain development
       - Tool slugs should match tools that exist from Phase 2 scraping (use common repos like solana-web3.js, ethers, hardhat, etc.)

       **Pack 2: "AI Agent Toolbox"**
       - Slug: `ai-agent-toolbox`
       - Tagline: "Build autonomous AI agents that can read, write, and act"
       - 5-8 tools related to AI agents, MCP servers, LLM frameworks

       **Pack 3: "Solana Builder Kit"**
       - Slug: `solana-builder-kit`
       - Tagline: "Ship Solana dApps from zero to deployment"
       - 5-8 tools related to Solana ecosystem

    4. The seed function should:
       a. For each pack, generate a UUID with `crypto.randomUUID()`
       b. Insert the pack record into `starterPacks`
       c. For each tool in the pack, look up the listing by slug: `db.query.listings.findFirst({ where: eq(listings.slug, toolSlug) })`
       d. If the tool exists, insert a `packTools` row linking pack and tool
       e. If the tool does NOT exist, log a warning: `console.warn('Tool not found: ${toolSlug} — skipping')`
       f. Log summary: "Seeded {N} packs with {M} tool links"

    5. Make the script runnable directly: `bun src/db/seed-packs.ts`
       - Add a main execution block at the bottom (checking `process.argv` or just running directly since Bun executes top-level)
       - Wrap in async main() with `.catch(console.error)`

    **CRITICAL: Tool slug lookup strategy.**
    The pack seed script references tools by slug. Since the catalog is populated by scrapers (Phase 2), the exact slugs depend on what was scraped. The seed script MUST gracefully handle missing tools (warn + skip). To maximize matches:
    - Use generic slug patterns that scrapers would generate (e.g., lowercase repo name with hyphens)
    - Include a mix of popular tools that are likely to exist in any seeded catalog
    - If fewer than 3 tools match for a pack, still create the pack (it will have a short tool list)
    - The executor should check dev.db for actual tool slugs and adjust the seed data accordingly: `cd /Users/clawdioversace/ai-bazaar && TURSO_DATABASE_URL=file:./dev.db bun -e "import { db } from './src/db/client'; const r = await db.query.listings.findMany({ columns: { slug: true, name: true, category: true }, limit: 300 }); console.log(JSON.stringify(r, null, 2));"` — then pick real slugs from the output.
  </action>
  <verify>
    TypeScript compiles: `cd /Users/clawdioversace/ai-bazaar && bunx tsc --noEmit --pretty 2>&1 | head -30`
    Service exports: `grep -n 'export.*function' src/services/packs.ts`
    Seed script runs: `cd /Users/clawdioversace/ai-bazaar && TURSO_DATABASE_URL=file:./dev.db bun src/db/seed-packs.ts 2>&1`
    Verify seeded data: `cd /Users/clawdioversace/ai-bazaar && TURSO_DATABASE_URL=file:./dev.db bun -e "import { db } from './src/db/client'; import { starterPacks } from './src/db/schema'; const p = await db.query.starterPacks.findMany(); console.log(p.length, 'packs seeded'); console.log(p.map(x => x.name));"`
  </verify>
  <done>
    PackService exports getPackWithTools and listPacks. Seed script creates 3+ packs with tools linked to existing catalog entries. Running `bun src/db/seed-packs.ts` populates dev.db with pack data. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/clawdioversace/ai-bazaar && bunx tsc --noEmit` — TypeScript compiles clean
2. `TURSO_DATABASE_URL=file:./dev.db bun src/db/migrate.ts` — migration runs, creates starter_packs and pack_tools tables
3. `TURSO_DATABASE_URL=file:./dev.db bun src/db/seed-packs.ts` — seeds 3+ packs with tool links
4. Verify pack count: `TURSO_DATABASE_URL=file:./dev.db bun -e "import { db } from './src/db/client'; const p = await db.query.starterPacks.findMany(); console.log(p.length + ' packs');"`
5. Verify tool links: `TURSO_DATABASE_URL=file:./dev.db bun -e "import { db } from './src/db/client'; import { packTools } from './src/db/schema'; const pt = await db.select().from(packTools); console.log(pt.length + ' pack-tool links');"`
6. Verify nested query works: `TURSO_DATABASE_URL=file:./dev.db bun -e "import { getPackWithTools } from './src/services/packs'; const p = await getPackWithTools('defi-dev-starter'); console.log(p?.name, p?.tools?.length + ' tools');"`
</verification>

<success_criteria>
- starterPacks and packTools tables exist in dev.db after migration
- Drizzle relations enable nested queries through junction table
- PackService provides getPackWithTools (with ordered tools) and listPacks
- At least 3 packs seeded with 5+ tool links each (or as many as exist in catalog)
- Cascade deletes work on both foreign keys
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-starter-packs/06-01-SUMMARY.md`
</output>
