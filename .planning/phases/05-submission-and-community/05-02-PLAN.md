---
phase: 05-submission-and-community
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/db/migrations/0002_add-upvotes-column.sql
  - src/app/tools/[slug]/page.tsx
  - src/app/tools/[slug]/actions.ts
  - src/components/upvote-button.tsx
  - src/lib/upvote-tracker.ts
autonomous: true

must_haves:
  truths:
    - "Any listing can be upvoted once per browser session with no authentication required"
    - "Upvote count is visible on the listing detail page"
    - "Clicking upvote a second time in the same session does nothing (button disabled)"
    - "Upvote UI updates instantly before server responds (optimistic update)"
    - "Upvotes use atomic SQL increment (no read-modify-write race condition)"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "upvotes column on listings table"
      contains: "upvotes"
    - path: "src/db/migrations/0002_add-upvotes-column.sql"
      provides: "Migration adding upvotes column with default 0"
      contains: "ALTER TABLE"
    - path: "src/components/upvote-button.tsx"
      provides: "Client Component with optimistic upvote UI"
      min_lines: 30
    - path: "src/lib/upvote-tracker.ts"
      provides: "sessionStorage utilities for tracking upvotes"
      exports: ["hasUpvoted", "markUpvoted"]
    - path: "src/app/tools/[slug]/actions.ts"
      provides: "Server Action for upvote increment"
      exports: ["upvoteListing"]
  key_links:
    - from: "src/components/upvote-button.tsx"
      to: "src/app/tools/[slug]/actions.ts"
      via: "useOptimistic + Server Action call"
      pattern: "upvoteListing"
    - from: "src/components/upvote-button.tsx"
      to: "src/lib/upvote-tracker.ts"
      via: "hasUpvoted/markUpvoted for session tracking"
      pattern: "hasUpvoted|markUpvoted"
    - from: "src/app/tools/[slug]/actions.ts"
      to: "src/db/client.ts"
      via: "Atomic SQL update: upvotes = upvotes + 1"
      pattern: "sql.*upvotes.*\\+ 1"
---

<objective>
Anonymous upvote system with optimistic UI and session-based duplicate prevention.

Purpose: Allows anyone to upvote a listing once per browser session without authentication. Uses React 19 useOptimistic for instant UI feedback, sessionStorage to prevent double-voting in a session, and atomic SQL increment to prevent race conditions.

Output: upvotes column in schema, migration, UpvoteButton client component, upvote Server Action, sessionStorage tracker utilities, integrated into listing detail page.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/db/schema.ts
@src/db/migrate.ts
@src/app/tools/[slug]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add upvotes column to schema and create migration</name>
  <files>
    src/db/schema.ts
    src/db/migrations/0002_add-upvotes-column.sql
    src/lib/upvote-tracker.ts
    src/app/tools/[slug]/actions.ts
  </files>
  <action>
    **In src/db/schema.ts:**
    Add upvotes column to the listings table definition, after the `downloads` field:
    ```typescript
    /** Community upvote count — incremented atomically via Server Action */
    upvotes: integer('upvotes').default(0),
    ```

    **In src/db/migrations/0002_add-upvotes-column.sql (new file):**
    Create a SQL migration that adds the upvotes column:
    ```sql
    ALTER TABLE listings ADD COLUMN upvotes integer DEFAULT 0;
    ```

    **IMPORTANT:** Do NOT use drizzle-kit generate or drizzle-kit push. Write the migration manually. This is a hard project rule (01-01 decision). Also update the migrations meta/_journal.json to include entry for 0002.

    Read `src/db/migrations/meta/_journal.json` to understand the format, then add a new entry with idx 2, version "7", tag "0002_add-upvotes-column", and a current timestamp.

    **In src/lib/upvote-tracker.ts (new file):**
    Create sessionStorage utilities for anonymous upvote tracking:
    ```typescript
    export function hasUpvoted(listingId: string): boolean {
      if (typeof window === 'undefined') return false;
      return sessionStorage.getItem(`upvote_${listingId}`) === 'true';
    }

    export function markUpvoted(listingId: string): void {
      if (typeof window === 'undefined') return;
      sessionStorage.setItem(`upvote_${listingId}`, 'true');
    }
    ```
    Include `typeof window === 'undefined'` guards for SSR safety.

    **In src/app/tools/[slug]/actions.ts (new file):**
    Create an upvote Server Action:
    1. Mark with `'use server'` directive
    2. Export `upvoteListing(listingId: string)` that:
       a. Validates listingId is a non-empty string
       b. Uses atomic SQL increment: `db.update(listings).set({ upvotes: sql\`upvotes + 1\`, updatedAt: new Date() }).where(eq(listings.id, listingId))`
       c. Calls `revalidatePath('/tools')` from `next/cache` to refresh cached pages
    3. Import `db` from `@/db/client`, `listings` from `@/db/schema`, `eq` and `sql` from `drizzle-orm`
    4. Wrap in try/catch, log errors but don't expose to client

    **Important for the SQL atomic increment:** Use `sql\`${listings.upvotes} + 1\`` syntax from drizzle-orm to generate `upvotes = upvotes + 1` SQL. This prevents read-modify-write race conditions.
  </action>
  <verify>
    Schema has upvotes: `grep -n 'upvotes' src/db/schema.ts`
    Migration exists: `cat src/db/migrations/0002_add-upvotes-column.sql`
    Actions file: `grep -n "'use server'" src/app/tools/[slug]/actions.ts`
    Tracker exports: `grep -n 'export' src/lib/upvote-tracker.ts`
    TypeScript compiles: `cd /Users/clawdioversace/ai-bazaar && bunx tsc --noEmit --pretty 2>&1 | head -30`
  </verify>
  <done>
    upvotes integer column added to schema.ts. Manual migration 0002 created. Upvote Server Action uses atomic SQL increment. sessionStorage tracker utilities exported. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create UpvoteButton component and integrate into detail page</name>
  <files>
    src/components/upvote-button.tsx
    src/app/tools/[slug]/page.tsx
  </files>
  <action>
    **In src/components/upvote-button.tsx (new file):**
    Create a Client Component ('use client') for the upvote button:
    1. Accept props: `{ listingId: string, initialUpvotes: number }`
    2. Use React 19 `useOptimistic` hook for instant UI feedback:
       ```typescript
       const [optimisticUpvotes, addOptimisticUpvote] = useOptimistic(
         initialUpvotes,
         (state: number) => state + 1
       )
       ```
    3. Use `useTransition` for the Server Action call
    4. Track upvote state with `useState` initialized from `hasUpvoted(listingId)` — NOT called during render (use useEffect to check after mount since sessionStorage is client-only)
    5. `handleUpvote` function:
       a. If already upvoted, return early
       b. Call `markUpvoted(listingId)` to set sessionStorage
       c. Set local `voted` state to true
       d. Inside `startTransition`:
          - Call `addOptimisticUpvote(null)` for instant UI
          - Call `await upvoteListing(listingId)` Server Action
    6. Render a button with:
       - Arrow-up SVG icon (simple triangle or chevron-up)
       - Upvote count text
       - `disabled` when `voted || isPending`
       - Visual state: default (zinc), voted (green/teal), pending (opacity-50)
       - Tailwind classes: `flex items-center gap-1.5 rounded-lg border px-3 py-2 text-sm font-medium transition-colors`
       - When voted: `border-green-200 bg-green-50 text-green-700 dark:border-green-800 dark:bg-green-900/30 dark:text-green-300`
       - When not voted: `border-zinc-200 bg-white text-zinc-700 hover:bg-zinc-50 dark:border-zinc-700 dark:bg-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700`

    **In src/app/tools/[slug]/page.tsx:**
    Integrate the UpvoteButton into the listing detail page:
    1. Import `UpvoteButton` from `@/components/upvote-button`
    2. Add the UpvoteButton in the main content area, after the tagline and before the category badge. Place it on its own row:
       ```tsx
       <UpvoteButton listingId={listing.id} initialUpvotes={listing.upvotes ?? 0} />
       ```
    3. The detail page remains a Server Component — it just renders the Client Component UpvoteButton within it (standard Next.js pattern)

    **Note:** The `useEffect` for checking sessionStorage is necessary because:
    - Server Components render on the server where `sessionStorage` is undefined
    - Even in Client Components, the initial render may be server-side (SSR)
    - useEffect runs only on client, so it's the safe place to check sessionStorage
    - Initialize `voted` state as `false`, then set it in useEffect based on `hasUpvoted()`
  </action>
  <verify>
    Component exists: `ls src/components/upvote-button.tsx`
    Is Client Component: `grep -n "'use client'" src/components/upvote-button.tsx`
    Uses useOptimistic: `grep -n 'useOptimistic' src/components/upvote-button.tsx`
    Integrated in detail page: `grep -n 'UpvoteButton' src/app/tools/\\[slug\\]/page.tsx`
    TypeScript compiles: `cd /Users/clawdioversace/ai-bazaar && bunx tsc --noEmit --pretty 2>&1 | head -30`
    Build succeeds: `cd /Users/clawdioversace/ai-bazaar && timeout 30 bun run build 2>&1 | tail -10`
  </verify>
  <done>
    UpvoteButton Client Component renders with optimistic UI, sessionStorage-based duplicate prevention, and visual state feedback. Integrated into /tools/[slug] detail page. Upvote count visible. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/clawdioversace/ai-bazaar && bunx tsc --noEmit` — TypeScript compiles clean
2. `bun run build` — Next.js build succeeds
3. Migration file at src/db/migrations/0002_add-upvotes-column.sql contains ALTER TABLE
4. Manual: Visit /tools/[any-slug], see upvote button with count, click to upvote, count increments, button becomes disabled
5. Manual: Refresh page in same tab — button still shows as voted (sessionStorage persists in session)
6. Manual: Open new tab — upvote button is enabled again (sessionStorage is tab-scoped)
</verification>

<success_criteria>
- upvotes column exists in schema and migration
- UpvoteButton shows current count and allows one click per session
- Optimistic UI updates instantly before server responds
- Atomic SQL increment prevents race conditions
- sessionStorage prevents double-voting within a session
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-submission-and-community/05-02-SUMMARY.md`
</output>
