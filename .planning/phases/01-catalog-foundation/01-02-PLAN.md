---
phase: 01-catalog-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tags.ts
  - src/lib/categories.ts
  - src/lib/catalog-schema.ts
autonomous: true

must_haves:
  truths:
    - "Tag normalization collapses 'mcp', 'MCP', 'mcp-server', 'mcpserver', 'model-context-protocol' to the canonical tag 'mcp-server'"
    - "Category enum contains exactly: mcp-server, ai-agent, web3-tool, defi-tool, infra, framework"
    - "Zod CatalogEntry schema validates all CAT-01 fields and rejects invalid categories"
    - "sourceUrl is normalized (trailing slash removed, www stripped) at parse time to prevent dedup failures"
    - "Duplicate tags in input are collapsed to unique set after normalization"
  artifacts:
    - path: "src/lib/tags.ts"
      provides: "TAG_ALIASES map and normalizeTag function"
      exports: ["TAG_ALIASES", "normalizeTag"]
    - path: "src/lib/categories.ts"
      provides: "CATEGORIES const array and Category type"
      exports: ["CATEGORIES", "Category"]
    - path: "src/lib/catalog-schema.ts"
      provides: "Zod CatalogEntry schema with transforms"
      exports: ["CatalogEntrySchema", "CatalogEntry", "CatalogEntryInput"]
  key_links:
    - from: "src/lib/catalog-schema.ts"
      to: "src/lib/tags.ts"
      via: "import normalizeTag"
      pattern: "import.*normalizeTag.*from.*tags"
    - from: "src/lib/catalog-schema.ts"
      to: "src/lib/categories.ts"
      via: "import CATEGORIES for z.enum"
      pattern: "import.*CATEGORIES.*from.*categories"
---

<objective>
Create the Zod validation schema and canonical taxonomies (tags + categories) that serve as the shared contract for the entire stack. Every piece of data entering the catalog -- from scrapers, submission forms, or MCP tools -- passes through this schema. Tag normalization and URL normalization happen at parse time, not in service code.

Purpose: This is the data contract. If this is wrong, everything downstream is wrong. Tag normalization (CAT-03), category validation (CAT-04), and URL dedup (CAT-01) are all enforced at this boundary.
Output: Three files in `src/lib/` that any service or consumer can import for validation and type inference.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-catalog-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tag taxonomy and category enum</name>
  <files>
    src/lib/tags.ts
    src/lib/categories.ts
  </files>
  <action>
    **Create `src/lib/tags.ts`:**

    Export a `TAG_ALIASES` constant of type `Record<string, string>` that maps variant tag strings to their canonical form. Include at minimum these alias groups:

    MCP variants: `'mcp'`, `'MCP'`, `'mcpserver'`, `'mcp_server'`, `'model-context-protocol'` all map to `'mcp-server'`

    ACP/A2A variants: `'acp'`, `'ACP'` map to `'acp-agent'`; `'a2a'`, `'A2A'` map to `'a2a-agent'`

    Web3 variants: `'web3'`, `'blockchain'`, `'onchain'`, `'on-chain'` map to `'web3-tool'`; `'defi'` maps to `'defi-tool'`

    Solana variants: `'sol'`, `'solana-network'` map to `'solana'`

    AI variants: `'ai'`, `'artificial-intelligence'`, `'machine-learning'`, `'ml'` map to `'ai-tool'`; `'llm'`, `'large-language-model'` map to `'llm-tool'`

    Export a `normalizeTag` function that:
    1. Lowercases and trims the input
    2. Replaces whitespace sequences with hyphens
    3. Looks up the cleaned string in TAG_ALIASES
    4. If not found, also looks up the original input string (for case-sensitive aliases like 'MCP')
    5. Returns the canonical form or the cleaned string if no alias exists

    **Create `src/lib/categories.ts`:**

    Export a `CATEGORIES` const array (using `as const`):
    ```typescript
    export const CATEGORIES = [
      'mcp-server',
      'ai-agent',
      'web3-tool',
      'defi-tool',
      'infra',
      'framework',
    ] as const;
    ```

    Export a `Category` type derived from the array: `typeof CATEGORIES[number]`.

    Export a `CATEGORY_LABELS` record mapping each category to a human-readable label:
    ```typescript
    export const CATEGORY_LABELS: Record<Category, string> = {
      'mcp-server': 'MCP Server',
      'ai-agent': 'AI Agent',
      'web3-tool': 'Web3 Tool',
      'defi-tool': 'DeFi Tool',
      'infra': 'Infrastructure',
      'framework': 'Framework',
    };
    ```

    Both files should be pure TypeScript with no runtime dependencies (no imports from other project files or external packages).
  </action>
  <verify>
    - `bunx tsc --noEmit src/lib/tags.ts src/lib/categories.ts` compiles without errors
    - Manually verify: `normalizeTag('MCP')` returns `'mcp-server'`, `normalizeTag('defi')` returns `'defi-tool'`, `normalizeTag('some-new-tag')` returns `'some-new-tag'`
  </verify>
  <done>
    TAG_ALIASES covers all variant groups from the research. normalizeTag correctly collapses variants to canonical forms. CATEGORIES array and Category type define the exact 6 categories from CAT-04. All exports are pure TypeScript with zero dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod CatalogEntry schema with tag and URL normalization transforms</name>
  <files>
    src/lib/catalog-schema.ts
  </files>
  <action>
    **Create `src/lib/catalog-schema.ts`:**

    Import `z` from `zod`, `normalizeTag` from `./tags`, and `CATEGORIES` from `./categories`.

    Define and export `CatalogEntrySchema` as a `z.object()` with these fields:

    - `id`: `z.string().uuid().optional()` -- generated if not provided
    - `slug`: `z.string().min(1).max(100).regex(/^[a-z0-9-]+$/)` -- URL-safe slug
    - `name`: `z.string().min(1).max(100)`
    - `tagline`: `z.string().min(1).max(160)`
    - `description`: `z.string().min(1).max(2000)`
    - `category`: `z.enum(CATEGORIES)` -- strict validation against canonical categories
    - `tags`: `z.array(z.string()).transform((tags) => [...new Set(tags.map(normalizeTag))])` -- normalize + deduplicate at parse time
    - `sourceUrl`: `z.string().url().transform((url) => { const parsed = new URL(url); return \`\${parsed.protocol}//\${parsed.hostname}\${parsed.pathname}\`.replace(/\\/$/, ''); })` -- normalize URL: strip trailing slash, strip query params, normalize protocol
    - `docsUrl`: `z.string().url().optional()`
    - `licenseType`: `z.string().optional()`
    - `runtime`: `z.enum(['node', 'python', 'rust', 'go', 'other']).optional()`
    - `chainSupport`: `z.array(z.string()).optional()`
    - `mcpCompatible`: `z.boolean().default(false)`
    - `acpCompatible`: `z.boolean().default(false)`
    - `stars`: `z.number().int().min(0).default(0)`
    - `downloads`: `z.number().int().min(0).default(0)`
    - `lastVerifiedAt`: `z.date().optional()`
    - `deadLink`: `z.boolean().default(false)`
    - `submittedBy`: `z.string().optional()`
    - `verified`: `z.boolean().default(false)`

    Export three types:
    - `CatalogEntry` = `z.infer<typeof CatalogEntrySchema>` (output type, after transforms)
    - `CatalogEntryInput` = `z.input<typeof CatalogEntrySchema>` (input type, before transforms)

    Also export a `createSlug` utility function:
    ```typescript
    export function createSlug(name: string): string {
      return name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '')
        .slice(0, 100);
    }
    ```

    This is used by scrapers and submission handlers to generate slugs from tool names. Keep it in this file since it is part of the catalog entry contract.

    Add a JSDoc comment on CatalogEntrySchema explaining that this is the shared validation contract: all data entering the catalog (scrapers, forms, MCP tools) MUST be parsed through this schema.
  </action>
  <verify>
    - `bunx tsc --noEmit src/lib/catalog-schema.ts` compiles without errors
    - Write a quick inline test (or verify mentally):
      - Parsing `{ tags: ['MCP', 'mcp', 'mcpserver'] }` within a valid entry yields `tags: ['mcp-server']` (deduplicated)
      - Parsing `{ sourceUrl: 'https://github.com/org/repo/' }` yields `sourceUrl: 'https://github.com/org/repo'` (trailing slash stripped)
      - Parsing `{ category: 'invalid' }` throws a Zod validation error
      - `createSlug('Anthropic Claude MCP')` returns `'anthropic-claude-mcp'`
  </verify>
  <done>
    CatalogEntrySchema validates all CAT-01 fields. Tags are normalized and deduplicated at parse time (CAT-03). Category is strictly validated against the canonical 6-item enum (CAT-04). Source URLs are normalized to prevent dedup failures. createSlug utility is exported for slug generation.
  </done>
</task>

</tasks>

<verification>
- `src/lib/tags.ts` exports TAG_ALIASES and normalizeTag
- `src/lib/categories.ts` exports CATEGORIES, Category, and CATEGORY_LABELS
- `src/lib/catalog-schema.ts` exports CatalogEntrySchema, CatalogEntry, CatalogEntryInput, createSlug
- Tag normalization works: 'MCP' -> 'mcp-server', 'defi' -> 'defi-tool'
- URL normalization works: trailing slashes stripped, www removed
- Category validation rejects strings not in the canonical 6
- All files compile with `bunx tsc --noEmit`
</verification>

<success_criteria>
Any service or scraper can `import { CatalogEntrySchema } from '@/lib/catalog-schema'` and parse untrusted input. After parsing, tags are guaranteed canonical, URLs are normalized, and categories are valid. The schema is the single source of truth for what constitutes a valid catalog entry.
</success_criteria>

<output>
After completion, create `.planning/phases/01-catalog-foundation/01-02-SUMMARY.md`
</output>
