---
phase: 01-catalog-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/services/catalog.ts
  - src/services/search.ts
  - src/lib/__tests__/catalog-service.test.ts
autonomous: true

must_haves:
  truths:
    - "A CatalogEntry can be created via CatalogService and retrieved by ID or slug"
    - "upsertBySourceUrl updates an existing entry (same sourceUrl) instead of creating a duplicate"
    - "markDeadLink updates only dead_link and last_verified_at without touching other fields"
    - "Full-text search for 'claude' returns listings with 'claude' in name, tagline, or description ranked by BM25 relevance"
    - "browseByCategory('mcp-server') returns only listings with category='mcp-server' and excludes dead links"
    - "Dead-link check via HEAD request returns true for 404/410 responses and false for 200 responses"
  artifacts:
    - path: "src/services/catalog.ts"
      provides: "CatalogService with CRUD, upsert, dead-link detection"
      exports: ["createListing", "getListingById", "getListingBySlug", "updateListing", "upsertBySourceUrl", "markDeadLink", "checkDeadLink"]
    - path: "src/services/search.ts"
      provides: "SearchService with FTS5 search and category browsing"
      exports: ["searchCatalog", "browseByCategory"]
    - path: "src/lib/__tests__/catalog-service.test.ts"
      provides: "Integration tests for CatalogService and SearchService"
  key_links:
    - from: "src/services/catalog.ts"
      to: "src/db/client.ts"
      via: "import db"
      pattern: "import.*db.*from.*db/client"
    - from: "src/services/catalog.ts"
      to: "src/db/schema.ts"
      via: "import listings table"
      pattern: "import.*listings.*from.*db/schema"
    - from: "src/services/catalog.ts"
      to: "src/lib/catalog-schema.ts"
      via: "import CatalogEntrySchema for validation"
      pattern: "import.*CatalogEntrySchema.*from.*catalog-schema"
    - from: "src/services/search.ts"
      to: "src/db/client.ts"
      via: "import db"
      pattern: "import.*db.*from.*db/client"
    - from: "src/services/search.ts"
      to: "src/db/schema.ts"
      via: "import listings for typed queries"
      pattern: "import.*listings.*from.*db/schema"
---

<objective>
Build CatalogService (all write operations) and SearchService (all read/search operations) on top of the Drizzle schema and Zod validation from Plans 01 and 02. These two services are the ONLY way any code in the project touches the database -- API routes, scrapers, and MCP tools all go through these services.

Purpose: Services enforce the rule that no raw SQL appears in consumer code. CatalogService handles CRUD + upsert + dead-link flagging. SearchService handles FTS5 full-text search and category browsing. Together they fulfill CAT-01 through CAT-07.
Output: Two service modules ready for import by any consumer (web routes, scrapers, MCP tools), plus integration tests proving the core flows work against a real SQLite database.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-catalog-foundation/01-RESEARCH.md
@.planning/phases/01-catalog-foundation/01-01-SUMMARY.md
@.planning/phases/01-catalog-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CatalogService with CRUD, upsert, and dead-link detection</name>
  <files>
    src/services/catalog.ts
  </files>
  <action>
    **Create `src/services/catalog.ts`:**

    Import `eq` from `drizzle-orm`, `db` from `../db/client`, `listings` and types from `../db/schema`, `CatalogEntrySchema` and `CatalogEntryInput` from `../lib/catalog-schema`.

    Implement these exported functions:

    **`createListing(input: CatalogEntryInput)`**
    1. Parse input through `CatalogEntrySchema.parse(input)` -- this normalizes tags and URLs
    2. Build a `NewListing` record: generate `id` via `crypto.randomUUID()` if not provided, serialize `tags` as `JSON.stringify(entry.tags)`, serialize `chainSupport` as JSON if present, set `createdAt` and `updatedAt` to `new Date()`
    3. Insert via `db.insert(listings).values(record)`
    4. Return the record

    **`getListingById(id: string)`**
    - `db.query.listings.findFirst({ where: (l, { eq }) => eq(l.id, id) })`

    **`getListingBySlug(slug: string)`**
    - `db.query.listings.findFirst({ where: (l, { eq }) => eq(l.slug, slug) })`

    **`updateListing(id: string, input: Partial<CatalogEntryInput>)`**
    1. If `input.tags` is provided, normalize via `input.tags.map(normalizeTag)` and serialize to JSON
    2. Set `updatedAt` to `new Date()`
    3. `db.update(listings).set({...}).where(eq(listings.id, id))`

    **`upsertBySourceUrl(input: CatalogEntryInput)`**
    1. Normalize the sourceUrl first (same transform as Zod schema -- strip trailing slash, normalize protocol)
    2. Look up existing: `db.query.listings.findFirst({ where: eq(listings.sourceUrl, normalizedUrl) })`
    3. If exists: call `updateListing(existing.id, input)`, return existing with updates
    4. If not exists: call `createListing(input)`, return new record
    IMPORTANT: The Zod schema already normalizes sourceUrl, but the lookup must use the SAME normalization to match correctly. Import the URL normalization logic or extract it to a shared helper.

    **`markDeadLink(id: string, isDead: boolean)`**
    - `db.update(listings).set({ deadLink: isDead, lastVerifiedAt: new Date(), updatedAt: new Date() }).where(eq(listings.id, id))`
    - This updates ONLY the dead_link flag and last_verified_at timestamp (CAT-06, CAT-07)

    **`checkDeadLink(sourceUrl: string): Promise<boolean>`**
    1. Create `AbortController` and set a `setTimeout` of 5000ms to call `controller.abort()` (NOT `AbortSignal.timeout()` due to Bun bug)
    2. `fetch(sourceUrl, { method: 'HEAD', signal: controller.signal, redirect: 'follow' })`
    3. Return `true` (dead) ONLY for status 404 or 410. All other statuses (including 405, 403, 5xx) return `false` (inconclusive, not definitively dead -- per research Pitfall 5)
    4. On catch (network error, abort): return `false` (inconclusive)
    5. Always `clearTimeout(timer)` in finally block

    **`getAllListings(limit = 50, offset = 0)`**
    - `db.query.listings.findMany({ limit, offset, orderBy: (l, { desc }) => [desc(l.createdAt)] })`
    - Simple paginated listing for admin/debug purposes

    Add JSDoc comments on each exported function explaining its role and that this is the only valid write path to the database.
  </action>
  <verify>
    - `bunx tsc --noEmit src/services/catalog.ts` compiles without errors
    - All imports resolve correctly (db/client, db/schema, lib/catalog-schema)
    - Function signatures match the documented exports
  </verify>
  <done>
    CatalogService exports 7 functions covering all write operations on the catalog. Data flows through Zod validation on create/upsert. Tag normalization happens at the schema boundary. URL dedup works via normalized sourceUrl lookup. Dead-link detection uses HEAD with manual AbortController timeout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SearchService and integration tests</name>
  <files>
    src/services/search.ts
    src/lib/__tests__/catalog-service.test.ts
  </files>
  <action>
    **Create `src/services/search.ts`:**

    Import `sql` from `drizzle-orm`, `db` from `../db/client`, `listings` and `Listing` type from `../db/schema`.

    Define and export a `SearchParams` interface:
    ```typescript
    export interface SearchParams {
      query: string;
      category?: string;
      tags?: string[];
      mcpCompatible?: boolean;
      limit?: number;
      offset?: number;
    }
    ```

    **`searchCatalog(params: SearchParams): Promise<Listing[]>`**
    1. Destructure params with defaults: `limit = 20, offset = 0`
    2. Use Drizzle's `sql` tagged template to execute a raw FTS5 MATCH query:
       ```sql
       SELECT l.*
       FROM listings_fts
       JOIN listings l ON listings_fts.rowid = l.rowid
       WHERE listings_fts MATCH ?
       AND l.dead_link = 0
       ORDER BY listings_fts.rank
       LIMIT ? OFFSET ?
       ```
    3. Add conditional SQL fragments for `category` filter (`AND l.category = ?`) and `mcpCompatible` filter (`AND l.mcp_compatible = 1`)
    4. If `tags` filter is provided, add `AND` clauses that check `l.tags LIKE '%"tag"%'` for each tag (JSON contains check -- simple but adequate for <5k rows)
    5. Return the results array typed as `Listing[]`
    6. Add a comment noting that FTS5 `rank` column is an alias for `bm25()` -- lower values = more relevant (ascending order = best first)

    **`browseByCategory(category: string, limit = 20, offset = 0): Promise<Listing[]>`**
    1. Use Drizzle's relational query API:
       ```typescript
       db.query.listings.findMany({
         where: (l, { eq, and }) => and(eq(l.category, category), eq(l.deadLink, false)),
         limit,
         offset,
         orderBy: (l, { desc }) => [desc(l.stars)],
       })
       ```
    2. This returns listings sorted by stars (most popular first), excluding dead links

    **`countByCategory(): Promise<Array<{ category: string; count: number }>>`**
    1. Raw SQL: `SELECT category, COUNT(*) as count FROM listings WHERE dead_link = 0 GROUP BY category ORDER BY count DESC`
    2. Useful for category navigation UI showing counts

    **`rebuildFtsIndex(): Promise<void>`**
    1. `db.run(sql\`INSERT INTO listings_fts(listings_fts) VALUES('rebuild')\`)`
    2. Call after any bulk insert operation that may bypass triggers
    3. Export this -- scrapers will need it after batch inserts

    **Create `src/lib/__tests__/catalog-service.test.ts`:**

    This is an integration test that runs against a real SQLite file (not mocked). Use Bun's built-in test runner (`bun test`).

    Setup: Before all tests, create a fresh test database:
    - Set `process.env.TURSO_DATABASE_URL = 'file:./test.db'`
    - Run migrations programmatically or shell out to `bunx drizzle-kit migrate`
    - Alternatively, import the db client and use it directly (the test.db will be created by libSQL if it doesn't exist, but schema needs to be applied)

    For simplicity, the test can shell out to apply migrations:
    ```typescript
    import { execSync } from 'child_process';
    // Apply migrations to test DB
    execSync('TURSO_DATABASE_URL=file:./test.db bunx drizzle-kit migrate', { cwd: process.cwd() });
    ```

    Or better: use a test setup script that creates the tables via raw SQL. The exact approach depends on what works cleanly with Bun test + Drizzle. Use pragmatic judgment.

    Test cases (minimum):

    1. **"createListing creates a listing and retrieves it by ID"**
       - Create a listing with all required fields
       - Retrieve by ID
       - Assert name, category, tags match

    2. **"upsertBySourceUrl updates existing instead of duplicating"**
       - Create a listing with sourceUrl = 'https://github.com/test/repo'
       - Upsert with same sourceUrl but different name
       - Assert only 1 listing exists (not 2)
       - Assert name is updated

    3. **"tag normalization works through CatalogService"**
       - Create a listing with tags: ['MCP', 'mcp', 'defi']
       - Retrieve it
       - Assert tags JSON contains 'mcp-server' and 'defi-tool' (normalized)
       - Assert no duplicates

    4. **"browseByCategory returns only matching category"**
       - Create 2 listings in 'mcp-server' and 1 in 'ai-agent'
       - Browse 'mcp-server'
       - Assert 2 results returned

    5. **"searchCatalog returns ranked FTS5 results"**
       - Create listings with distinct names
       - Search for a term in one listing's name
       - Assert that listing appears in results

    6. **"markDeadLink updates flag without changing other fields"**
       - Create a listing
       - Call markDeadLink(id, true)
       - Retrieve and assert deadLink = true and lastVerifiedAt is updated
       - Assert name and other fields are unchanged

    Add `test.db` to `.gitignore`.

    If Bun test setup is complex, add a comment explaining the test database approach and ensure `bun test` runs from the project root.
  </action>
  <verify>
    - `bunx tsc --noEmit src/services/search.ts src/services/catalog.ts` compiles
    - `bun test` runs and all 6 test cases pass
    - Test output shows createListing, upsert dedup, tag normalization, category browse, FTS5 search, and dead-link flag all working
  </verify>
  <done>
    SearchService provides FTS5 full-text search with BM25 ranking (CAT-02), category browsing (CAT-04), category counts, and FTS5 index rebuild. Integration tests prove: CRUD works (CAT-01), upsert dedup works, tag normalization works (CAT-03), category browse filters correctly (CAT-04), FTS5 search returns results (CAT-02), and markDeadLink updates only the right fields (CAT-06, CAT-07). All 6 tests pass against a real SQLite database.
  </done>
</task>

</tasks>

<verification>
- CatalogService: create, read (by id + slug), update, upsert, markDeadLink, checkDeadLink, getAllListings all exported
- SearchService: searchCatalog (FTS5), browseByCategory, countByCategory, rebuildFtsIndex all exported
- Integration tests pass covering the 5 success criteria from the roadmap
- No raw SQL in any file except SearchService (which uses Drizzle's sql`` template for FTS5 -- this is the sanctioned pattern)
- All data flows through CatalogEntrySchema.parse() on write operations
- Dead-link detection uses AbortController + setTimeout (not AbortSignal.timeout)
</verification>

<success_criteria>
Running `bun test` passes all integration tests. A consumer can import CatalogService to write data and SearchService to query it, without knowing anything about the database schema or SQL. The 5 phase success criteria from ROADMAP.md are all demonstrated by the test suite:
1. CRUD via CatalogService (no direct SQL)
2. FTS5 search returns ranked results
3. Category browsing filters correctly
4. Tag normalization collapses variants
5. lastVerifiedAt and deadLink can be updated independently
</success_criteria>

<output>
After completion, create `.planning/phases/01-catalog-foundation/01-03-SUMMARY.md`
</output>
