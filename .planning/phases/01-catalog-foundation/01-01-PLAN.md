---
phase: 01-catalog-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - next.config.ts
  - drizzle.config.ts
  - .env.local
  - .env.example
  - src/db/schema.ts
  - src/db/client.ts
  - src/db/migrations/
autonomous: true

must_haves:
  truths:
    - "Drizzle schema compiles and generates a valid migration for the listings table"
    - "FTS5 virtual table and sync triggers are created via a custom migration"
    - "drizzle-kit migrate runs without error against a local SQLite file"
    - "The listings table has all fields from CAT-01 (name, tagline, description, category, tags, sourceUrl, docsUrl, licenseType, runtime, chainSupport, mcpCompatible, acpCompatible, stars, downloads, lastVerifiedAt, deadLink)"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "Drizzle listings table definition with all CAT-01 fields"
      contains: "sqliteTable"
    - path: "src/db/client.ts"
      provides: "Drizzle client singleton with libSQL connection"
      contains: "drizzle"
    - path: "drizzle.config.ts"
      provides: "Drizzle config for Turso dialect"
      contains: "dialect"
    - path: "src/db/migrations/"
      provides: "Schema migration + FTS5 custom migration"
  key_links:
    - from: "src/db/client.ts"
      to: "src/db/schema.ts"
      via: "import * as schema"
      pattern: "import.*schema"
    - from: "drizzle.config.ts"
      to: "src/db/schema.ts"
      via: "schema config field"
      pattern: "schema.*src/db/schema"
---

<objective>
Initialize the AI Bazaar project and create the complete database layer: Drizzle ORM schema for the listings table, libSQL client singleton, drizzle config, and both the schema migration and the FTS5 custom migration with sync triggers.

Purpose: This is the foundation everything else builds on. No service code, no validation, no search can exist without the database schema and connection layer being solid first.
Output: A working Next.js project with Drizzle ORM connected to a local SQLite file, listings table created, and FTS5 virtual table with INSERT/UPDATE/DELETE triggers ready for full-text search.
</objective>

<execution_context>
@/Users/clawdioversace/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clawdioversace/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-catalog-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Next.js project and install database dependencies</name>
  <files>
    package.json
    tsconfig.json
    next.config.ts
    .env.local
    .env.example
    .gitignore
  </files>
  <action>
    Initialize a Next.js project in the ai-bazaar root directory:

    ```bash
    bun create next-app . --typescript --tailwind --app --no-git
    ```

    If the command fails because the directory is not empty (due to .planning/ and .git/), use the interactive prompts or create in a temp dir and move files. The key files needed from Next.js init are: package.json, tsconfig.json, next.config.ts, src/app/ scaffolding.

    After Next.js init, install database dependencies:

    ```bash
    bun add drizzle-orm @libsql/client zod
    bun add -D drizzle-kit
    ```

    Create `.env.local` with:
    ```
    TURSO_DATABASE_URL=file:./dev.db
    TURSO_AUTH_TOKEN=
    ```

    Create `.env.example` with the same keys but empty values (for git tracking).

    Update `.gitignore` to include:
    - `dev.db` (local SQLite file)
    - `.env.local`
    - `node_modules/`
    - `.next/`

    Do NOT install @modelcontextprotocol/sdk yet -- that is Phase 4.
  </action>
  <verify>
    - `bun run build` succeeds (Next.js compiles)
    - `bunx drizzle-kit --version` outputs a version number
    - `.env.local` exists with `TURSO_DATABASE_URL=file:./dev.db`
  </verify>
  <done>Next.js project initialized with TypeScript, Tailwind, App Router. Drizzle ORM, @libsql/client, Zod, and drizzle-kit installed. Environment configured for local SQLite development.</done>
</task>

<task type="auto">
  <name>Task 2: Create Drizzle schema, client singleton, config, and FTS5 migration</name>
  <files>
    src/db/schema.ts
    src/db/client.ts
    drizzle.config.ts
    src/db/migrations/
  </files>
  <action>
    **Step 1: Create `src/db/schema.ts`** with the listings table definition.

    All fields from CAT-01 requirement:
    - `id` TEXT PRIMARY KEY (crypto.randomUUID())
    - `slug` TEXT NOT NULL UNIQUE (url-safe)
    - `name` TEXT NOT NULL
    - `tagline` TEXT NOT NULL (max 160 chars)
    - `description` TEXT NOT NULL
    - `category` TEXT NOT NULL (from canonical enum)
    - `tags` TEXT NOT NULL (JSON array stored as string)
    - `sourceUrl` TEXT NOT NULL UNIQUE (dedup key, maps to column `source_url`)
    - `docsUrl` TEXT (nullable, maps to `docs_url`)
    - `licenseType` TEXT (nullable, maps to `license_type`)
    - `runtime` TEXT (nullable)
    - `chainSupport` TEXT (nullable, JSON array, maps to `chain_support`)
    - `mcpCompatible` INTEGER boolean default false (maps to `mcp_compatible`)
    - `acpCompatible` INTEGER boolean default false (maps to `acp_compatible`)
    - `stars` INTEGER default 0
    - `downloads` INTEGER default 0
    - `lastVerifiedAt` INTEGER timestamp (maps to `last_verified_at`)
    - `deadLink` INTEGER boolean default false (maps to `dead_link`)
    - `submittedBy` TEXT nullable (maps to `submitted_by`)
    - `verified` INTEGER boolean default false
    - `createdAt` INTEGER timestamp NOT NULL (maps to `created_at`)
    - `updatedAt` INTEGER timestamp NOT NULL (maps to `updated_at`)

    Export `Listing` (select type) and `NewListing` (insert type) using `$inferSelect` and `$inferInsert`.

    Use `drizzle-orm/sqlite-core` imports: `sqliteTable`, `text`, `integer`.

    **Step 2: Create `drizzle.config.ts`** at project root.

    Use the `turso` dialect. Point `schema` to `./src/db/schema.ts`. Set `out` to `./src/db/migrations`. Load credentials from `process.env.TURSO_DATABASE_URL` and `process.env.TURSO_AUTH_TOKEN`. Add a comment warning NOT to use `drizzle-kit push` in this project (it destroys FTS5 virtual tables).

    **Step 3: Create `src/db/client.ts`** as the Drizzle client singleton.

    Import `drizzle` from `drizzle-orm/libsql`. Import `* as schema` from `./schema`. Create and export `const db = drizzle(...)` with connection url from `process.env.TURSO_DATABASE_URL!` and authToken from `process.env.TURSO_AUTH_TOKEN` (optional for local dev). Pass `schema` to enable relational queries.

    **Step 4: Generate the schema migration.**

    ```bash
    bunx drizzle-kit generate
    ```

    This creates the SQL migration for the `listings` table in `src/db/migrations/`.

    **Step 5: Generate the FTS5 custom migration.**

    ```bash
    bunx drizzle-kit generate --custom --name=fts5-listings-index
    ```

    Edit the generated empty custom migration file to contain:

    ```sql
    CREATE VIRTUAL TABLE IF NOT EXISTS listings_fts USING fts5(
      name,
      tagline,
      description,
      tags,
      content='listings',
      content_rowid='rowid'
    );

    INSERT INTO listings_fts(listings_fts) VALUES('rebuild');

    CREATE TRIGGER IF NOT EXISTS listings_ai AFTER INSERT ON listings BEGIN
      INSERT INTO listings_fts(rowid, name, tagline, description, tags)
      VALUES (new.rowid, new.name, new.tagline, new.description, new.tags);
    END;

    CREATE TRIGGER IF NOT EXISTS listings_ad AFTER DELETE ON listings BEGIN
      INSERT INTO listings_fts(listings_fts, rowid, name, tagline, description, tags)
      VALUES ('delete', old.rowid, old.name, old.tagline, old.description, old.tags);
    END;

    CREATE TRIGGER IF NOT EXISTS listings_au AFTER UPDATE ON listings BEGIN
      INSERT INTO listings_fts(listings_fts, rowid, name, tagline, description, tags)
      VALUES ('delete', old.rowid, old.name, old.tagline, old.description, old.tags);
      INSERT INTO listings_fts(rowid, name, tagline, description, tags)
      VALUES (new.rowid, new.name, new.tagline, new.description, new.tags);
    END;
    ```

    IMPORTANT: The `tags` column in FTS5 will receive the raw JSON string from the main table (via triggers). This is a known concern from research -- the FTS5 tokenizer will include brackets and quotes. For Phase 1, this is acceptable; the SearchService query will use the name/tagline/description columns primarily. A dedicated tag filter query (exact match on the main table's `tags` JSON column) handles tag-specific filtering. Document this in a code comment.

    **Step 6: Run the migrations against the local SQLite file.**

    ```bash
    bunx drizzle-kit migrate
    ```

    Verify the tables were created:
    ```bash
    bunx drizzle-kit studio
    ```
    Or use sqlite3 CLI if available:
    ```bash
    sqlite3 dev.db ".tables"
    ```

    Expected output should include `listings`, `listings_fts`, and drizzle migration tables.
  </action>
  <verify>
    - `sqlite3 dev.db ".tables"` (or equivalent) shows `listings` and `listings_fts`
    - `sqlite3 dev.db "SELECT sql FROM sqlite_master WHERE name='listings_ai'"` returns the INSERT trigger SQL
    - `sqlite3 dev.db "PRAGMA table_info(listings)"` shows all expected columns
    - TypeScript compiles: `bunx tsc --noEmit src/db/schema.ts src/db/client.ts` (or similar check)
  </verify>
  <done>
    Drizzle schema defines the complete listings table with all CAT-01 fields. FTS5 virtual table and three sync triggers are created via custom migration. Migrations run successfully against local SQLite. Client singleton is ready for import by services.
  </done>
</task>

</tasks>

<verification>
- The `listings` table exists in `dev.db` with all required columns from CAT-01
- The `listings_fts` virtual table exists and is linked to the `listings` table
- Three triggers (`listings_ai`, `listings_ad`, `listings_au`) exist for FTS5 sync
- `src/db/client.ts` exports a `db` instance that can be imported
- `drizzle.config.ts` uses `turso` dialect and points to the correct schema
- `bun run build` still passes (Next.js compilation works with new files)
</verification>

<success_criteria>
A developer can import `{ db }` from `src/db/client` and `{ listings }` from `src/db/schema` and immediately run Drizzle queries against the local SQLite database. The FTS5 index is ready to receive data when rows are inserted into the listings table.
</success_criteria>

<output>
After completion, create `.planning/phases/01-catalog-foundation/01-01-SUMMARY.md`
</output>
